From 1a05ff4948d778280ec155a9abe69d3360bfddd9 Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Wed, 17 Oct 2018 18:36:24 +0200
Subject: [PATCH] =?UTF-8?q?core:=20when=20deserializing=20state=20always?=
 =?UTF-8?q?=20use=20read=5Fline(=E2=80=A6,=20LONG=5FLINE=5FMAX,=20?=
 =?UTF-8?q?=E2=80=A6)?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This should be much better than fgets(), as we can read substantially
longer lines and overly long lines result in proper errors.

Fixes a vulnerability discovered by Jann Horn at Google.

CVE-2018-15686
LP: #1796402
https://bugzilla.redhat.com/show_bug.cgi?id=1639071

(cherry picked from commit 8948b3415d762245ebf5e19d80b97d4d8cc208c1)
---
 src/core/job.c     | 19 +++++++++++--------
 src/core/manager.c | 44 ++++++++++++++++++++------------------------
 src/core/unit.c    | 34 ++++++++++++++++++----------------
 src/core/unit.h    |  2 +-
 4 files changed, 50 insertions(+), 49 deletions(-)

Index: b/src/core/job.c
===================================================================
--- a/src/core/job.c	2018-11-13 17:17:11.856247297 -0500
+++ b/src/core/job.c	2018-11-13 17:17:11.852247237 -0500
@@ -38,6 +38,7 @@
 #include "async.h"
 #include "virt.h"
 #include "dbus.h"
+#include "fileio.h"
 
 Job* job_new_raw(Unit *unit) {
         Job *j;
@@ -945,23 +946,27 @@ int job_serialize(Job *j, FILE *f, FDSet
 }
 
 int job_deserialize(Job *j, FILE *f, FDSet *fds) {
+        int r;
+
         assert(j);
 
         for (;;) {
-                char line[LINE_MAX], *l, *v;
+                _cleanup_free_ char *line = NULL;
+                char *l, *v;
                 size_t k;
 
-                if (!fgets(line, sizeof(line), f)) {
-                        if (feof(f))
-                                return 0;
-                        return -errno;
+                r = read_line(f, LONG_LINE_MAX, &line);
+                if (r < 0) {
+                        log_error("Failed to read serialization line: %m", r);
+                        return r;
                 }
+                if (r == 0)
+                        return 0;
 
-                char_array_0(line);
                 l = strstrip(line);
 
                 /* End marker */
-                if (l[0] == 0)
+                if (isempty(l))
                         return 0;
 
                 k = strcspn(l, "=");
Index: b/src/core/manager.c
===================================================================
--- a/src/core/manager.c	2018-11-13 17:17:11.856247297 -0500
+++ b/src/core/manager.c	2018-11-13 17:17:11.852247237 -0500
@@ -77,6 +77,7 @@
 #include "dbus-job.h"
 #include "dbus-manager.h"
 #include "bus-kernel.h"
+#include "fileio.h"
 
 /* As soon as 5s passed since a unit was added to our GC queue, make sure to run a gc sweep */
 #define GC_QUEUE_USEC_MAX (10*USEC_PER_SEC)
@@ -2310,21 +2311,20 @@ int manager_deserialize(Manager *m, FILE
         m->n_reloading ++;
 
         for (;;) {
-                char line[LINE_MAX], *l;
-
-                if (!fgets(line, sizeof(line), f)) {
-                        if (feof(f))
-                                r = 0;
-                        else
-                                r = -errno;
+                _cleanup_free_ char *line = NULL;
+                char *l;
 
+                r = read_line(f, LONG_LINE_MAX, &line);
+                if (r < 0) {
+                        log_error("Failed to read serialization line: %m", r);
                         goto finish;
                 }
+                if (r == 0)
+                        break;
 
-                char_array_0(line);
                 l = strstrip(line);
 
-                if (l[0] == 0)
+                if (isempty(l)) /* end marker */
                         break;
 
                 if (startswith(l, "current-job-id=")) {
@@ -2442,21 +2442,18 @@ int manager_deserialize(Manager *m, FILE
 
         for (;;) {
                 Unit *u;
-                char name[UNIT_NAME_MAX+2];
+                _cleanup_free_ char *line = NULL;
 
                 /* Start marker */
-                if (!fgets(name, sizeof(name), f)) {
-                        if (feof(f))
-                                r = 0;
-                        else
-                                r = -errno;
-
+                r = read_line(f, LONG_LINE_MAX, &line);
+                if (r < 0) {
+                        log_error("Failed to read serialization line: %m", r);
                         goto finish;
                 }
+                if (r == 0)
+                        break;
 
-                char_array_0(name);
-
-                r = manager_load_unit(m, strstrip(name), NULL, NULL, &u);
+                r = manager_load_unit(m, strstrip(line), NULL, NULL, &u);
                 if (r < 0)
                         goto finish;
 
@@ -2466,9 +2463,6 @@ int manager_deserialize(Manager *m, FILE
         }
 
 finish:
-        if (ferror(f))
-                r = -EIO;
-
         assert(m->n_reloading > 0);
         m->n_reloading --;
 
Index: b/src/core/unit.c
===================================================================
--- a/src/core/unit.c	2018-11-13 17:17:11.856247297 -0500
+++ b/src/core/unit.c	2018-11-13 17:17:11.852247237 -0500
@@ -46,6 +46,7 @@
 #include "missing.h"
 #include "mkdir.h"
 #include "label.h"
+#include "fileio.h"
 #include "fileio-label.h"
 #include "bus-errors.h"
 #include "dbus.h"
@@ -2413,20 +2414,21 @@ int unit_deserialize(Unit *u, FILE *f, F
                 rt = (ExecRuntime**) ((uint8_t*) u + offset);
 
         for (;;) {
-                char line[LINE_MAX], *l, *v;
+                _cleanup_free_ char *line = NULL;
                 size_t k;
+                char *l, *v;
 
-                if (!fgets(line, sizeof(line), f)) {
-                        if (feof(f))
-                                return 0;
-                        return -errno;
+                r = read_line(f, LONG_LINE_MAX, &line);
+                if (r < 0) {
+                        log_error("Failed to read serialization line: %m", r);
+                        return r;
                 }
+                if (r == 0) /* eof */
+                        break;
 
-                char_array_0(line);
                 l = strstrip(line);
 
-                /* End marker */
-                if (l[0] == 0)
+                if (isempty(l)) /* End marker */
                         return 0;
 
                 k = strcspn(l, "=");
