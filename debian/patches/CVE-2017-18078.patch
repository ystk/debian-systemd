From 5579f85663d10269e7ac7464be6548c99cea4ada Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Tue, 23 Jan 2018 14:03:34 +0100
Subject: [PATCH] tmpfiles: refuse to chown()/chmod() files which are
 hardlinked, unless protected_hardlinks sysctl is on

Let's add some extra safety.

Fixes: #7736

[sunweaver] Integration of hardlink_vulnerable() call in item_set_perms.

---
 src/tmpfiles/tmpfiles.c | 43 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 43 insertions(+)

--- a/src/tmpfiles/tmpfiles.c
+++ b/src/tmpfiles/tmpfiles.c
@@ -54,6 +54,7 @@
 #include "specifier.h"
 #include "build.h"
 #include "copy.h"
+#include "fileio.h"
 
 /* This reads all files listed in /etc/tmpfiles.d/?*.conf and creates
  * them in the file system. This is intended to be used to create
@@ -452,6 +453,39 @@
         return r;
 }
 
+static bool dangerous_hardlinks(void) {
+        _cleanup_free_ char *value = NULL;
+        static int cached = -1;
+        int r;
+
+        /* Check whether the fs.protected_hardlinks sysctl is on. If we can't determine it we assume its off, as that's
+         * what the upstream default is. */
+
+        if (cached >= 0)
+                return cached;
+
+        r = read_one_line_file("/proc/sys/fs/protected_hardlinks", &value);
+        if (r < 0) {
+                log_debug("Failed to read fs.protected_hardlinks sysctl: %m");
+                return true;
+        }
+
+        r = parse_boolean(value);
+        if (r < 0) {
+                log_debug("Failed to parse fs.protected_hardlinks sysctl: %m");
+                return true;
+        }
+
+        cached = r == 0;
+        return cached;
+}
+
+static bool hardlink_vulnerable(struct stat *st) {
+        assert(st);
+
+        return !S_ISDIR(st->st_mode) && st->st_nlink > 1 && dangerous_hardlinks();
+}
+
 static int item_set_perms(Item *i, const char *path) {
         struct stat st;
         bool st_valid;
@@ -461,6 +495,12 @@
 
         st_valid = stat(path, &st) == 0;
 
+        if (st_valid && hardlink_vulnerable(&st)) {
+                log_error("Refusing to set permissions on hardlinked file %s while the fs.protected_hardlinks sysctl is turned off.",
+                          path);
+                return -EPERM;
+        }
+
         /* not using i->path directly because it may be a glob */
         if (i->mode_set) {
                 mode_t m = i->mode;
