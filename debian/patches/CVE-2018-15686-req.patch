Description: backport read_line() from systemd master
 CVE-2018-15686 requires a refactoring of fgets() to use the internal
 read_line() instead, which is not present in v215.
Author: Antoine Beaupré <anarcat@debian.org>
Bug-Debian: https://bugs.debian.org/912005
Forwarded: not-needed
Last-Update: 2018-11-13

Index: b/src/shared/fileio.c
===================================================================
--- a/src/shared/fileio.c	2018-11-13 16:49:29.615301247 -0500
+++ b/src/shared/fileio.c	2018-11-13 16:49:36.075399435 -0500
@@ -20,12 +20,15 @@
 ***/
 
 #include <unistd.h>
+#include <stdio.h>
+#include <stdio_ext.h>
 #include <sys/sendfile.h>
 #include "fileio.h"
 #include "util.h"
 #include "strv.h"
 #include "utf8.h"
 #include "ctype.h"
+#include "def.h"
 
 int write_string_stream(FILE *f, const char *line) {
         assert(f);
@@ -96,7 +99,7 @@ int write_string_file_atomic(const char
 
 int read_one_line_file(const char *fn, char **line) {
         _cleanup_fclose_ FILE *f = NULL;
-        char t[LINE_MAX], *c;
+        int r;
 
         assert(fn);
         assert(line);
@@ -105,21 +108,10 @@ int read_one_line_file(const char *fn, c
         if (!f)
                 return -errno;
 
-        if (!fgets(t, sizeof(t), f)) {
-
-                if (ferror(f))
-                        return errno ? -errno : -EIO;
-
-                t[0] = 0;
-        }
-
-        c = strdup(t);
-        if (!c)
-                return -ENOMEM;
-        truncate_nl(c);
+        (void) __fsetlocking(f, FSETLOCKING_BYCALLER);
 
-        *line = c;
-        return 0;
+        r = read_line(f, LONG_LINE_MAX, line);
+        return r < 0 ? r : 0;
 }
 
 ssize_t sendfile_full(int out_fd, const char *fn) {
@@ -864,3 +856,75 @@ int get_status_field(const char *filenam
 
         return 0;
 }
+
+DEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, funlockfile);
+
+int read_line(FILE *f, size_t limit, char **ret) {
+        _cleanup_free_ char *buffer = NULL;
+        size_t n = 0, allocated = 0, count = 0;
+
+        assert(f);
+
+        /* Something like a bounded version of getline().
+         *
+         * Considers EOF, \n and \0 end of line delimiters, and does not include these delimiters in the string
+         * returned.
+         *
+         * Returns the number of bytes read from the files (i.e. including delimiters — this hence usually differs from
+         * the number of characters in the returned string). When EOF is hit, 0 is returned.
+         *
+         * The input parameter limit is the maximum numbers of characters in the returned string, i.e. excluding
+         * delimiters. If the limit is hit we fail and return -ENOBUFS.
+         *
+         * If a line shall be skipped ret may be initialized as NULL. */
+
+        if (ret) {
+                if (!GREEDY_REALLOC(buffer, allocated, 1))
+                        return -ENOMEM;
+        }
+
+        {
+                _unused_ _cleanup_(funlockfilep) FILE *flocked = f;
+                flockfile(f);
+
+                for (;;) {
+                        int c;
+
+                        if (n >= limit)
+                                return -ENOBUFS;
+
+                        errno = 0;
+                        c = fgetc_unlocked(f);
+                        if (c == EOF) {
+                                /* if we read an error, and have no data to return, then propagate the error */
+                                if (ferror_unlocked(f) && n == 0)
+                                        return errno > 0 ? -errno : -EIO;
+
+                                break;
+                        }
+
+                        count++;
+
+                        if (IN_SET(c, '\n', 0)) /* Reached a delimiter */
+                                break;
+
+                        if (ret) {
+                                if (!GREEDY_REALLOC(buffer, allocated, n + 2))
+                                        return -ENOMEM;
+
+                                buffer[n] = (char) c;
+                        }
+
+                        n++;
+                }
+        }
+
+        if (ret) {
+                buffer[n] = 0;
+
+                *ret = buffer;
+                buffer = NULL;
+        }
+
+        return (int) count;
+}
Index: b/src/shared/fileio.h
===================================================================
--- a/src/shared/fileio.h	2018-11-13 16:49:29.615301247 -0500
+++ b/src/shared/fileio.h	2018-11-13 16:49:29.615301247 -0500
@@ -43,3 +43,5 @@ int write_env_file(const char *fname, ch
 int executable_is_script(const char *path, char **interpreter);
 
 int get_status_field(const char *filename, const char *pattern, char **field);
+
+int read_line(FILE *f, size_t limit, char **ret);
Index: b/src/shared/def.h
===================================================================
--- a/src/shared/def.h	2018-11-13 16:49:29.615301247 -0500
+++ b/src/shared/def.h	2018-11-13 16:49:29.615301247 -0500
@@ -76,3 +76,5 @@
 #ifndef TTY_GID
 #define TTY_GID 5
 #endif
+
+#define LONG_LINE_MAX (1U*1024U*1024U)
