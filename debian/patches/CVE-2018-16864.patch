From: =?utf-8?q?Antoine_Beaupr=C3=A9?= <anarcat@debian.org>
Date: Tue, 12 Mar 2019 17:46:26 +0100
Subject: journald: do not store the iovec entry for process commandline on
 stack

Bug-Debian: https://bugs.debian.org/918841
Origin: Debian
Bug: https://bugzilla.redhat.com/show_bug.cgi?id=1653855
Forwarded: not-needed
Last-Update: 2019-03-13

This fixes a crash (CVE-2018-16864) where we
would read the commandline, whose length is under control of the
sending program, and then crash when trying to create a stack
allocation for it. It also includes the fix for CVE-2019-3815, a memory leak
introduced by the fix for CVE-2018-16864.

This is a backport of https://github.com/systemd/systemd/commit/084eeb865ca63887098e0945fb4e93c852b91b0f
---
 src/journal/journald-server.c | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/src/journal/journald-server.c b/src/journal/journald-server.c
index 1c69563..923e8ea 100644
--- a/src/journal/journald-server.c
+++ b/src/journal/journald-server.c
@@ -552,6 +552,7 @@ static void dispatch_message_real(
                 o_uid[sizeof("OBJECT_UID=") + DECIMAL_STR_MAX(uid_t)],
                 o_gid[sizeof("OBJECT_GID=") + DECIMAL_STR_MAX(gid_t)],
                 o_owner_uid[sizeof("OBJECT_SYSTEMD_OWNER_UID=") + DECIMAL_STR_MAX(uid_t)];
+        _cleanup_free_ char *cmdline1 = NULL, *cmdline2 = NULL;
         uid_t object_uid;
         gid_t object_gid;
         char *x;
@@ -602,9 +603,12 @@ static void dispatch_message_real(
 
                 r = get_process_cmdline(ucred->pid, 0, false, &t);
                 if (r >= 0) {
-                        x = strappenda("_CMDLINE=", t);
+                        /* At most _SC_ARG_MAX (2MB usually), which is
+                         * too much to put on stack. Let's use a heap
+                         * allocation for this one. */ 
+                        cmdline1 = strappend("_CMDLINE=", t);
                         free(t);
-                        IOVEC_SET_STRING(iovec[n++], x);
+                        IOVEC_SET_STRING(iovec[n++], cmdline1);
                 }
 
                 r = get_process_capeff(ucred->pid, &t);
@@ -716,9 +720,11 @@ static void dispatch_message_real(
 
                 r = get_process_comm(object_pid, &t);
                 if (r >= 0) {
-                        x = strappenda("OBJECT_COMM=", t);
+                        /* See above for size limits, only ->cmdline
+                         * may be large, so use a heap allocation for it. */
+                        cmdline2 = strappend("OBJECT_COMM=", t);
                         free(t);
-                        IOVEC_SET_STRING(iovec[n++], x);
+                        IOVEC_SET_STRING(iovec[n++], cmdline2);
                 }
 
                 r = get_process_exe(object_pid, &t);
