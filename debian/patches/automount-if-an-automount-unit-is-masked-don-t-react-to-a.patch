From: Lennart Poettering <lennart@poettering.net>
Date: Wed, 1 Mar 2017 04:03:48 +0100
Subject: automount: if an automount unit is masked,
 don't react to activation anymore (#5445)

Otherwise we'll hit an assert sooner or later.

This requires us to initialize ->where even if we come back in "masked"
mode, as otherwise we don't know how to operate on the automount and
detach it.

Fixes: #5441
(backported from commit e350ca3f1ecb6672b74cd25d09ef23c7b309aa5a)
---
 src/core/automount.c | 67 +++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 45 insertions(+), 22 deletions(-)

diff --git a/src/core/automount.c b/src/core/automount.c
index 73a8ce1..4392635 100644
--- a/src/core/automount.c
+++ b/src/core/automount.c
@@ -87,17 +87,19 @@ static void unmount_autofs(Automount *a) {
         if (a->pipe_fd < 0)
                 return;
 
-        automount_send_ready(a, -EHOSTDOWN);
 
         a->pipe_event_source = sd_event_source_unref(a->pipe_event_source);
         a->pipe_fd = safe_close(a->pipe_fd);
 
-        /* If we reload/reexecute things we keep the mount point
-         * around */
-        if (a->where &&
-            (UNIT(a)->manager->exit_code != MANAGER_RELOAD &&
-             UNIT(a)->manager->exit_code != MANAGER_REEXECUTE))
-                repeat_unmount(a->where);
+        /* If we reload/reexecute things we keep the mount point around */
+        if (!IN_SET(UNIT(a)->manager->exit_code, MANAGER_RELOAD, MANAGER_REEXECUTE)) {
+
+                automount_send_ready(a, -EHOSTDOWN);
+
+                if (a->where) {
+                        repeat_unmount(a->where);
+                }
+        }
 }
 
 static void automount_done(Unit *u) {
@@ -169,6 +171,21 @@ static int automount_verify(Automount *a) {
         return 0;
 }
 
+static int automount_set_where(Automount *a) {
+
+        assert(a);
+
+        if (a->where)
+                return 0;
+
+        a->where = unit_name_to_path(UNIT(a)->id);
+        if (!a->where)
+                return -ENOMEM;
+
+        path_kill_slashes(a->where);
+        return 1;
+}
+
 static int automount_load(Unit *u) {
         Automount *a = AUTOMOUNT(u);
         int r;
@@ -184,13 +201,9 @@ static int automount_load(Unit *u) {
         if (u->load_state == UNIT_LOADED) {
                 Unit *x;
 
-                if (!a->where) {
-                        a->where = unit_name_to_path(u->id);
-                        if (!a->where)
-                                return -ENOMEM;
-                }
-
-                path_kill_slashes(a->where);
+                r = automount_set_where(a);
+                if (r < 0)
+                        return r;
 
                 r = unit_load_related_unit(u, ".mount", &x);
                 if (r < 0)
@@ -242,21 +255,25 @@ static int automount_coldplug(Unit *u) {
         assert(a);
         assert(a->state == AUTOMOUNT_DEAD);
 
-        if (a->deserialized_state != a->state) {
+        if (a->deserialized_state == a->state)
+                return 0;
+
+        if (IN_SET(a->deserialized_state, AUTOMOUNT_WAITING, AUTOMOUNT_RUNNING)) {
+
+                r = automount_set_where(a);
+                if (r < 0)
+                        return r;
 
                 r = open_dev_autofs(u->manager);
                 if (r < 0)
                         return r;
 
-                if (a->deserialized_state == AUTOMOUNT_WAITING ||
-                    a->deserialized_state == AUTOMOUNT_RUNNING) {
+                assert(a->pipe_fd >= 0);
 
-                        assert(a->pipe_fd >= 0);
+                r = sd_event_add_io(u->manager->event, &a->pipe_event_source, a->pipe_fd, EPOLLIN, automount_dispatch_io, u);
+                if (r < 0)
+                        return r;
 
-                        r = sd_event_add_io(u->manager->event, &a->pipe_event_source, a->pipe_fd, EPOLLIN, automount_dispatch_io, u);
-                        if (r < 0)
-                                return r;
-                }
 
                 automount_set_state(a, a->deserialized_state);
         }
@@ -548,6 +565,12 @@ static void automount_enter_runnning(Automount *a) {
 
         assert(a);
 
+        /* If the user masked our unit in the meantime, fail */
+        if (UNIT(a)->load_state != UNIT_LOADED) {
+                log_error_unit(UNIT(a)->id, "Suppressing automount event since unit is no longer loaded.");
+                goto fail;
+        }
+
         /* We don't take mount requests anymore if we are supposed to
          * shut down anyway */
         if (unit_stop_pending(UNIT(a))) {
